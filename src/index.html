<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta >
    <script src="websr.js"> </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;400;800&display=swap" rel="stylesheet">
    <script src="image-compare-viewer.min.js"></script>
    <link href="image-compare-viewer.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
    <script src="mp4-muxer.js"></script>
    <title>Free AI Video Upscaler</title>
    <style>

        body{
            font-family:  'Manrope', sans-serif;
        }

        h1{
            width: 100%;
            text-align: center;
            color: #232554;
            margin: 4rem 0;
            font-weight: 800;
            font-size: 4rem;
        }


        .panel{
            display: none;
            width: 640px;
            margin: auto;
            background: #F5F5F5;
            border-radius: 1.25rem;
            height: 22.5rem;
            padding: 20px 30px;
            -webkit-box-sizing: border-box; /* Safari/Chrome, other WebKit */
            -moz-box-sizing: border-box;    /* Firefox, other Gecko */
            box-sizing: border-box;         /* Opera/IE 8+ */
            border: .06rem solid #c8c8d5;
        }
        p{
            width: 640px;
            margin: auto;
            display: block;
            text-align: center;
            margin-bottom:  20px;
        }

        video {
            margin: -20px -30px 10px -30px;
        }
        #error{
            display: none;
        }
        #loading{
            width: 100%;
        }

        #file-load-panel{
            display: block;
        }

        #done{
            display: none;
        }

        #download-link{
            position: relative;
            display: none;
            margin: auto;
            width: fit-content;
        }

        #hero-text{
            color: #232554;
            font-size: 1.25rem;
            margin: 3em auto;
        }
        .panel-text{
            width: 100%;
            font-size: 1.5rem;
            text-align: center;
            margin: 20px auto;
        }
        button{
            margin: auto;
            display: block;
        }
        #missing-component{
            font-family: monospace;
            background: #e5e5e5;
            border-radius: 8px;
            padding: 5px 10px;
            margin: 0 5px;
            font-size: 1.25rem;
        }
        #input-button{
            margin: 4rem auto;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 800;
            display: block;
        }

        #unsupported-panel{
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #footer{

            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            color: #999;

            text-align: center;
            font-size: 0.85rem;
            padding: 20px;
        }
    </style>
</head>

<body >



<h1 id="title">Free AI Video Upscaler</h1>
<p id="hero-text">This free tool applies an <a href="https://github.com/sb2702/websr">AI Upscaling algorithm</a> on your video, right in the browser. It is much faster, though not as powerful, as other popular AI Upscaling software.</p>

<div id="unsupported-panel" class="panel" >
    <p class="panel-text">Your browser does not support <span id="missing-component"></span>, a required browser feature for this tool.</p>
</div>

<div id="file-load-panel" class="panel" >
    <p class="panel-text">Choose a video to upscale</p>
    <button type="button" class="btn btn-primary"  id="input-button" onclick="chooseFile(this)">Choose a video file</button>
</div>
<!--<input type="file" onchange="loadVideo(this)" accept="video/mp4,video/webm">-->
<div id="start-panel" class="panel">


    <div id="image-compare">
        <video id="video" width="640" height="360"></video>
        <canvas id="upscaled" ></canvas>
    </div>


    <p id="error">An error ocurred while upscaling</p>
    <br>
    <p id="loading">Upscaling...</p>

    <div id="info">
        <div class="progress" id="progress">
            <div  class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 75%"></div>
        </div>
    </div>

    <a id="download-link" href=""  style=""><button  type="button" class="btn btn-primary" id="download">Download
    <img src="download-icon.svg" width="20" />
    </button></a>

    <input id="done" type="button" value="Upscale another video" onclick="refresh()">
</div>


<div id="footer">
    <div style="float: left">
        Souce code <a href="https://github.com/sb2702/free-ai-video-upscaler" >on Github</a>.  &nbsp;  &nbsp; Â© Sam Bhattacharyya 2024
    </div>

    <div style="float: right">
        Issues, questions or suggestions, go <a href="https://github.com/sb2702/free-ai-video-upscaler/issues"> here</a>
    </div>


</div>




<script>

    const video  =  document.getElementById("video");
    const canvas = document.getElementById("upscaled")

    let destinationFileName = "upscaled.mp4";
    let finished;

    var pending_outputs = 0;
    let frames_processed = 0;
    const progress  = document.getElementById("info");

    let gpu;

    async function main() {

        if(!"VideoEncoder" in window) return showUnsupported("WebCodecs");

        gpu = await WebSR.initWebGPU();

        if(!gpu) return showUnsupported("WebGPU");

        window.chooseFile =  chooseFile;

    }
    function chooseFile(e) {
        const input = document.createElement('input');
        input.type = 'file';
        input.onchange = inputHandler;
        input.click();
    }

    main();

    function showUnsupported(text) {
        console.log("Unsupported");
        $("#file-load-panel").hide();
        $("#start-panel").hide();
        $("#unsupported-panel").show();
        $("#missing-component").text(text);

    }


    function inputHandler(input){

        const file = input.files[0];
        const url = URL.createObjectURL(file);

        const reader = new FileReader();

        reader.onload = function (e) {
            setupUpscaler(url);
        }

        destinationFileName = file.name.split(".")[0] + "-upscaled.mp4";
        reader.readAsDataURL(file);

    }

    async function setupUpscaler(url) {
        video.src = url;

        video.onloadeddata = async function (){
            const websr = new WebSR({
                source: video,
                network_name: "anime4k/cnn-2x-s",
                weights: await (await fetch('cnn-2x-s.json')).json(),
                 gpu: gpu,
                canvas: canvas
            });


            $("#file-load-panel").hide();

            canvas.width = video.videoWidth*2;
            canvas.height = video.videoHeight*2;

            video.volume = 0.01;

            document.getElementById('start-panel').style.display = "block";

            // View them side by side
            new ImageCompare( document.getElementById("image-compare")).mount();



            const muxer = new Mp4Muxer.Muxer({
                target: new Mp4Muxer.ArrayBufferTarget(),
                video: {
                    codec: 'avc',
                    width: video.videoWidth*2,
                    height: video.videoHeight*2
                },
                audio: {
                    codec:  'aac',
                    numberOfChannels: 2,
                    sampleRate: 48000
                },
                fastStart: 'in-memory'
            });



            const audioEncoder = new AudioEncoder({
                output: function (encodedAudioChunk) {
                    muxer.addAudioChunk(encodedAudioChunk);
                },
                error: (e)=> console.log(e)
            })

            let finished= false;

            audioEncoder.configure({
                codec: 'mp4a.40.2',
                sampleRate: 48000,
                numberOfChannels: 2
            })


            function copyAudioData(inputBuffer) {
                // This function should copy data from inputBuffer into a new ArrayBuffer
                // The implementation depends on how you want to handle the audio data
                const numberOfChannels = inputBuffer.numberOfChannels;
                const numberOfFrames = inputBuffer.length;
                const outputArray = new Float32Array(numberOfChannels * numberOfFrames);

                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const inputData = inputBuffer.getChannelData(channel);
                    for (let frame = 0; frame < numberOfFrames; frame++) {
                        outputArray[frame * numberOfChannels + channel] = inputData[frame];
                    }

                }

                return outputArray.buffer;
            }


            const encoder_config = {
                codec: 'avc1.42001f',
                width: video.videoWidth*2,
                height: video.videoHeight*2,
                bitrate: 1e7,
                framerate: 30,
            };


            const init = {
                output: (chunk, meta) => {
                    handleEncoded(chunk, meta);
                },
                error: (e) => {
                    console.log(e.message);
                }
            };

            let encoder = new VideoEncoder(init);
            encoder.configure(encoder_config);


            const frameStack = [];

           async function decodeLoop() {
               let bitmap = await createImageBitmap(video);
               frameStack.push({
                   frame: bitmap,
                   time: video.currentTime
               });
               pending_outputs +=1;
               if(frameStack.length > 40) video.pause();
               video.requestVideoFrameCallback(decodeLoop);
           }


           window.frameStack = frameStack;
           async function encodeLoop() {
               if(frameStack.length ===0 && !video.ended) return video.requestVideoFrameCallback(encodeLoop);
               const { frame, time } = frameStack.shift();

               await websr.render(frame);

               const upscaled_bitmap = await createImageBitmap(canvas);


               const upscaled_frame = new VideoFrame(upscaled_bitmap, { timestamp: time*1000*1000});

               const isKeyFrame = frames_processed %60 ===0;

               let progress  = Math.floor(time/video.duration*100);

               $('.progress-bar').css('width', progress+'%').attr('aria-valuenow', progress);
               frames_processed +=1;


               pending_outputs --;

               encoder.encode(upscaled_frame, { keyFrame: isKeyFrame});

               upscaled_frame.close();

               if(!(video.ended && frameStack.length ===0) ) await encodeLoop();
           }


           let initPlaybackTime = null;


            video.requestVideoFrameCallback(async  function () {
                let bitmap = await createImageBitmap(video);
                frameStack.push({
                    frame: bitmap,
                    time: video.currentTime
                });

                pending_outputs +=1;

                const audioStream = video.captureStream().getAudioTracks()[0];
                
                const audioContext = new AudioContext();
                const source  = audioContext.createMediaStreamSource(new MediaStream([audioStream]));

                const processor = audioContext.createScriptProcessor(4096, 2, 2);

                source.connect(processor);
                processor.connect(audioContext.destination);
                processor.onaudioprocess = function (e) {

                    if(finished) return;

                    const inputBuffer = e.inputBuffer;

                    if(!initPlaybackTime) initPlaybackTime = e.playbackTime;

                    const numberOfChannels = inputBuffer.numberOfChannels;
                    const numberOfFrames = inputBuffer.length;
                    const sampleRate = inputBuffer.sampleRate;


                    // Create an AudioData object
                    let audioData = new AudioData({
                        format: 'f32', // assuming the audio data is in 32-bit float format
                        sampleRate: sampleRate,
                        numberOfFrames: numberOfFrames,
                        numberOfChannels: numberOfChannels,
                        timestamp: (e.playbackTime -initPlaybackTime)* sampleRate, // or other appropriate timestamp
                        data: copyAudioData(inputBuffer) // You'll need to copy data from inputBuffer
                    });

                    audioEncoder.encode(audioData);
                }



                video.play();

                video.requestVideoFrameCallback(decodeLoop);
            });





            video.requestVideoFrameCallback(encodeLoop);


            video.onended = async function () {
                if(video.ended && pending_outputs < 1 && !finished) return await onEnd();
            }

            async function onEnd() {

                $('#info').hide();

                finished = true;
                await encoder.flush()
                await audioEncoder.flush();
                await audioEncoder.close();
                muxer.finalize();


                const blob = new Blob([muxer.target.buffer], {type: "video/mp4"});

                const url = window.URL.createObjectURL(blob);


                const button = document.getElementById('download-link');
                button.href = url;
                button.download = destinationFileName;
                button.style.display = "block";

                $('#loading').hide();
            }

            async function handleEncoded(chunk, meta){

                muxer.addVideoChunk(chunk, meta);

                if(video.ended && pending_outputs < 1 && !finished) return await onEnd();

            }




        }

    }



</script>

</body>

</html>