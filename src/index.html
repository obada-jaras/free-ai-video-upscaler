<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta >
    <script src="websr.js"> </script>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <script src="image-compare-viewer.min.js"></script>
    <link href="image-compare-viewer.min.css" rel="stylesheet">
    <script src="mp4-muxer.js"></script>
    <title>Video Upscaler</title>
    <style>

        body{
            font-family: 'Open Sans', sans-serif;
        }

        h3{
            width: 100%;
            text-align: center;
            color: #666;
            font-weight: normal;
        }

        #logo{
            height: 70px;
            margin: auto;
            display: block;
        }
        .panel{
            display: none;
            width: 640px;
            margin: auto;
            background: #F5F5F5;
            padding: 20px 30px;
            -webkit-box-sizing: border-box; /* Safari/Chrome, other WebKit */
            -moz-box-sizing: border-box;    /* Firefox, other Gecko */
            box-sizing: border-box;         /* Opera/IE 8+ */
        }
        p{
            width: 640px;
            margin: auto;
            display: block;
            text-align: center;
            margin-bottom:  20px;
        }

        video {
            margin: -20px -30px 10px -30px;
        }
        #error{
            display: none;
        }

        #file-load-panel{
            display: block;
        }

        #done{
            display: none;
        }
    </style>
</head>

<body >



<h3>AI Video Upscaler</h3>
<p>This free upscaling software is <b>experimental</b>. It works up to 100x faster than other AI Upscalers, but the quality improvement may be less noticeable.</p>

<div id="unsupported-panel" class="panel" >
    <p>Your browser doesn't have the functionality needed for AI Upscaling. Please use the latest version of Google Chrome. If you are currently using Chrome, open  <pre>chrome://flags/#enable-experimental-web-platform-features</pre> in a new tab, and enable "Experimental Web Platform features". When you come back to this page, you should be able to upload a video. If you think there's still an issue, contact us at team@vectorly.io</p>
</div>

<div id="file-load-panel" class="panel" >
    <p>Choose a video to upscale</p>
    <input type="file" onchange="loadVideo(this)" accept="video/mp4,video/webm">
</div>

<div id="start-panel" class="panel">


    <div id="image-compare">
        <video id="video" width="640" height="360"></video>
        <canvas id="upscaled" ></canvas>
    </div>

    <p id="loading">Loading...</p>
    <p id="error">An error ocurred while upscaling</p>
    <div  id="download" style="display: none;"></div>

    <div id="info"></div>

    <input id="done" type="button" value="Upscale another video" onclick="refresh()">
</div>






<script>

    const video  =  document.getElementById("video");
    const canvas = document.getElementById("upscaled")

    let destinationFileName = "upscaled.mp4";;
    let finished;

    var pending_outputs = 0;
    let frames_processed = 0;
    const progress  = document.getElementById("info");

    let gpu;
    
    async function main() {

        if(!"VideoEncoder" in window) return showUnsupported("Your Browser doesn't support WebCodecs");

        gpu = await WebSR.initWebGPU();

        if(!gpu) return showUnsupported("Your Browser doesn't support WebGPU");

        window.loadVideo = inputHandler;

    }

    main();

    function showUnsupported() {

    }


    function inputHandler(input){

        const file = input.files[0];
        const url = URL.createObjectURL(file);

        const reader = new FileReader();

        reader.onload = function (e) {
            setupUpscaler(url);
        }

        destinationFileName = file.name.split(".")[0] + "-upscaled.mp4";
        reader.readAsDataURL(file);

    }

    async function setupUpscaler(url) {
        video.src = url;

        video.onloadeddata = async function (){
            const websr = new WebSR({
                source: video,
                network_name: "anime4k/cnn-2x-s",
                weights: await (await fetch('cnn-2x-s.json')).json(),
                 gpu: gpu,
                canvas: canvas
            });


            canvas.width = video.videoWidth*2;
            canvas.height = video.videoHeight*2;

            video.volume = 0.01;

            document.getElementById('start-panel').style.display = "block";

            // View them side by side
            new ImageCompare( document.getElementById("image-compare")).mount();



            const muxer = new Mp4Muxer.Muxer({
                target: new Mp4Muxer.ArrayBufferTarget(),
                video: {
                    codec: 'avc',
                    width: video.videoWidth*2,
                    height: video.videoHeight*2
                },
                audio: {
                    codec:  'aac',
                    numberOfChannels: 2,
                    sampleRate: 48000
                },
                fastStart: 'in-memory'
            });



            const audioEncoder = new AudioEncoder({
                output: function (encodedAudioChunk) {
                    muxer.addAudioChunk(encodedAudioChunk);
                },
                error: (e)=> console.log(e)
            })

            let finished= false;

            audioEncoder.configure({
                codec: 'mp4a.40.2',
                sampleRate: 48000,
                numberOfChannels: 2
            })


            function copyAudioData(inputBuffer) {
                // This function should copy data from inputBuffer into a new ArrayBuffer
                // The implementation depends on how you want to handle the audio data
                const numberOfChannels = inputBuffer.numberOfChannels;
                const numberOfFrames = inputBuffer.length;
                const outputArray = new Float32Array(numberOfChannels * numberOfFrames);

                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const inputData = inputBuffer.getChannelData(channel);
                    for (let frame = 0; frame < numberOfFrames; frame++) {
                        outputArray[frame * numberOfChannels + channel] = inputData[frame];
                    }

                }

                return outputArray.buffer;
            }


            const encoder_config = {
                codec: 'avc1.42001f',
                width: video.videoWidth*2,
                height: video.videoHeight*2,
                bitrate: 1e7,
                framerate: 30,
            };


            const init = {
                output: (chunk, meta) => {
                    handleEncoded(chunk, meta);
                },
                error: (e) => {
                    console.log(e.message);
                }
            };

            let encoder = new VideoEncoder(init);
            encoder.configure(encoder_config);


            const frameStack = [];

           async function decodeLoop() {
               let bitmap = await createImageBitmap(video);
               frameStack.push({
                   frame: bitmap,
                   time: video.currentTime
               });
               pending_outputs +=1;
               if(frameStack.length > 40) video.pause();
               video.requestVideoFrameCallback(decodeLoop);
           }


           window.frameStack = frameStack;
           async function encodeLoop() {
               if(frameStack.length ===0 && !video.ended) return video.requestVideoFrameCallback(encodeLoop);
               const { frame, time } = frameStack.shift();

               await websr.render(frame);

               const upscaled_bitmap = await createImageBitmap(canvas);


               const upscaled_frame = new VideoFrame(upscaled_bitmap, { timestamp: time*1000*1000});

               const isKeyFrame = frames_processed %60 ===0;


               frames_processed +=1;


               pending_outputs --;

               encoder.encode(upscaled_frame, { keyFrame: isKeyFrame});

               upscaled_frame.close();

               if(!(video.ended && frameStack.length ===0) ) await encodeLoop();
           }


           let initPlaybackTime = null;


            video.requestVideoFrameCallback(async  function () {
                let bitmap = await createImageBitmap(video);
                frameStack.push({
                    frame: bitmap,
                    time: video.currentTime
                });

                pending_outputs +=1;

                const audioStream = video.captureStream().getAudioTracks()[0];
                
                const audioContext = new AudioContext();
                const source  = audioContext.createMediaStreamSource(new MediaStream([audioStream]));

                const processor = audioContext.createScriptProcessor(4096, 2, 2);

                source.connect(processor);
                processor.connect(audioContext.destination);
                processor.onaudioprocess = function (e) {

                    if(finished) return;

                    const inputBuffer = e.inputBuffer;

                    if(!initPlaybackTime) initPlaybackTime = e.playbackTime;

                    const numberOfChannels = inputBuffer.numberOfChannels;
                    const numberOfFrames = inputBuffer.length;
                    const sampleRate = inputBuffer.sampleRate;


                    // Create an AudioData object
                    let audioData = new AudioData({
                        format: 'f32', // assuming the audio data is in 32-bit float format
                        sampleRate: sampleRate,
                        numberOfFrames: numberOfFrames,
                        numberOfChannels: numberOfChannels,
                        timestamp: (e.playbackTime -initPlaybackTime)* sampleRate, // or other appropriate timestamp
                        data: copyAudioData(inputBuffer) // You'll need to copy data from inputBuffer
                    });

                    audioEncoder.encode(audioData);
                }



                video.play();

                video.requestVideoFrameCallback(decodeLoop);
            });





            video.requestVideoFrameCallback(encodeLoop);


            video.onended = async function () {
                if(video.ended && pending_outputs < 1 && !finished) return await onEnd();
            }

            async function onEnd() {

                finished = true;
                await encoder.flush()
                await audioEncoder.flush();
                await audioEncoder.close();
                muxer.finalize();


                const blob = new Blob([muxer.target.buffer], {type: "video/mp4"});

                const url = window.URL.createObjectURL(blob);


                const anchor = document.createElement("a");
                anchor.href = url;
                anchor.download = destinationFileName;
                anchor.innerText = "Download me";
                document.body.appendChild(anchor);
            }

            async function handleEncoded(chunk, meta){

                muxer.addVideoChunk(chunk, meta);

                if(video.ended && pending_outputs < 1 && !finished) return await onEnd();

            }




        }

    }




</script>

</body>

</html>